{"method_name": "UpdateElements", "positive": "method UpdateElements(a: array<int>)\n  requires a.Length >=9\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[8] == old(a[8])\n  ensures a[7]==516\n{\n  a[4] := a[4] + 3;\n  a[7] := 516;\n}```\n"}
{"method_name": "UpdateElements", "positive": "method UpdateElements(a: array<int>)\n  requires a.Length >=9\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[8] == old(a[8])\n  ensures a[7]==516\n{\n  a[4] := a[4] + 3;\n  a[7] := 516;\n}\n````\n"}
{"method_name": "Min", "positive": "method Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n{\n  if (x <= y) {\n    return x;\n  } else {\n    return y;\n  }\n}```\n"}
{"method_name": "Min", "positive": "method Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n{\n  if (x <= y) {\n    return x;\n  } else {\n    return y;\n  }\n}```\n"}
{"method_name": "ComputeAvg", "positive": "method ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n{\n  // complete the method body here\n  avg := (a + b) / 2;\n}```\n"}
{"method_name": "ComputeAvg", "positive": "method ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n{\n  // complete the method body here\n  avg := (a + b) / 2;\n}\n````\n"}
{"method_name": "CalDiv", "positive": "method CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n{\n  var temp: int;\n  temp := 191;\n  x := temp / 7;\n  y := temp % 7;\n}```\n"}
{"method_name": "CalDiv", "positive": "method CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n{\n  var temp: int;\n  temp := 191;\n  x := temp / 7;\n  y := temp % 7;\n}\n````\n"}
{"method_name": "swap", "positive": "method swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n  modifies arr\n{\n  // complete this method\n  var temp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := temp;\n}```\n"}
{"method_name": "swap", "positive": "method swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n  modifies arr\n{\n  // complete this method\n  var temp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := temp;\n}\n````\n"}
{"method_name": "Find", "positive": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  //complete the method\n  index := 0;\n  while (index < a.Length)\n    invariant 0 <= index <= a.Length\n    invariant (forall i :: 0 <= i < index ==> a[i] != key)\n  {\n    if (a[index] == key) {\n      return index;\n    }```\n"}
{"method_name": "Find", "positive": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  //complete the method\n  index := 0;\n  while (index < a.Length)\n    invariant 0 <= index <= a.Length\n    invariant (forall i :: 0 <= i < index ==> a[i] != key)\n  {\n    if (a[index] == key) {\n      return index;\n    }```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := 3 * x;\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := 3 * x;\n}\n````\n"}
{"method_name": "LinearSearch3", "positive": "method LinearSearch3<T>(a: array<T>, P: T -> bool) returns (n: int)\n  requires exists i :: 0 <= i < a.Length && P(a[i])\n  ensures 0 <= n < a.Length && P(a[n])\n  ensures forall k :: 0 <= k < n ==> !P(a[k])\n{\n  // Fill in the body of this method using Dafny's language features.\n  // Here's a possible solution:\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> !P(a[k])\n  {\n    if P(a[i]) {\n      return i;\n    }```\n"}
{"method_name": "LinearSearch3", "positive": "method LinearSearch3<T>(a: array<T>, P: T -> bool) returns (n: int)\n  requires exists i :: 0 <= i < a.Length && P(a[i])\n  ensures 0 <= n < a.Length && P(a[n])\n  ensures forall k :: 0 <= k < n ==> !P(a[k])\n{\n  // Fill in the body of this method using Dafny's language features.\n  // Here's a possible solution:\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> !P(a[k])\n  {\n    if P(a[i]) {\n      return i;\n    }```\n"}
{"method_name": "modify", "positive": "method modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall some_index1: nat, some_index2: nat ::\n            some_index1 < arr.Length && some_index2 < arr[some_index1].Length ==>\n              arr[some_index1][some_index2] == if index1 == some_index1 && index2 == some_index2\n              then val else old(arr[some_index1][some_index2])\n{\n  arr[index1][index2] := val;\n}```\n"}
{"method_name": "modify", "positive": "method modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall some_index1: nat, some_index2: nat ::\n            some_index1 < arr.Length && some_index2 < arr[some_index1].Length ==>\n              arr[some_index1][some_index2] == if index1 == some_index1 && index2 == some_index2\n              then val else old(arr[some_index1][some_index2])\n{\n  arr[index1][index2] := val;\n}\n````\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := 3 * x;\n}\n````\n"}
{"method_name": "Sum", "positive": "method Sum() returns (s:int, n:int)\n  ensures s == n * (n + 1) / 2\n  ensures n==33\n{\n  // complete this method\n  n := 33;\n  var i := 0;\n  s := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}```\n"}
{"method_name": "Sum", "positive": "method Sum() returns (s:int, n:int)\n  ensures s == n * (n + 1) / 2\n  ensures n==33\n{\n  // complete this method\n  n := 33;\n  var i := 0;\n  s := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}```\n"}
{"method_name": "maxArray", "positive": "method maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  // Here is a possible completion:\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> m >= a[j]\n    invariant exists j :: 0 <= j < i && m == a[j]\n  {\n    if a[i] > m {\n      m := a[i];\n    }```\n"}
{"method_name": "maxArray", "positive": "method maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  // Here is a possible completion:\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> m >= a[j]\n    invariant exists j :: 0 <= j < i && m == a[j]\n  {\n    if a[i] > m {\n      m := a[i];\n    }```\n"}
{"method_name": "minArray", "positive": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> r <= a[j]\n    invariant exists j :: 0 <= j < i && r == a[j]\n  {\n    if a[i] < r {\n      r := a[i];\n    }```\n"}
{"method_name": "minArray", "positive": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall j :: 0 <= j < i ==> r <= a[j]\n    invariant exists j :: 0 <= j < i && r == a[j]\n  {\n    if a[i] < r {\n      r := a[i];\n    }```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := x + x + x;\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := x + x + x;\n}\n````\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n\n{\n  n := 0;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall k :: 0 <= k < n ==> a[k]!=e\n  {\n    if a[n] == e {\n      return n;\n    }```\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n\n{\n  n := 0;\n  while n < a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall k :: 0 <= k < n ==> a[k]!=e\n  {\n    if a[n] == e {\n      return n;\n    }```\n"}
{"method_name": "iter", "positive": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n  ensures s.Length==t.Length\n  ensures forall i::0<=i<s.Length ==> s[i]==t[i]\n{\n  // complete this method\n  t := new T[s.Length];\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> s[j] == t[j]\n  {\n    t[i] := s[i];\n    i := i + 1;\n  }\n}```\n"}
{"method_name": "iter", "positive": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n  ensures s.Length==t.Length\n  ensures forall i::0<=i<s.Length ==> s[i]==t[i]\n{\n  // complete this method\n  t := new T[s.Length];\n  var i := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall j :: 0 <= j < i ==> s[j] == t[j]\n  {\n    t[i] := s[i];\n    i := i + 1;\n  }\n}```\n"}
{"method_name": "SwapBitvectors", "positive": "method SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n{\n  // Complete this method\n  x := X;\n  y := Y;\n  var tmp: bv8 := x;\n  x := y;\n  y := tmp;\n}```\n"}
{"method_name": "SwapBitvectors", "positive": "method SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n{\n  // Complete this method\n  x := X;\n  y := Y;\n  var tmp: bv8 := x;\n  x := y;\n  y := tmp;\n}\n````\n"}
{"method_name": "MultipleReturns", "positive": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n{\n  if x > y {\n    more := x + y;\n    less := x - y;\n  } else {\n    more := x + y;\n    less := x - y;\n  }\n}```\n"}
{"method_name": "MultipleReturns", "positive": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n{\n  if x > y {\n    more := x + y;\n    less := x - y;\n  } else {\n    more := x + y;\n    less := x - y;\n  }\n}```\n"}
{"method_name": "DoubleQuadruple", "positive": "method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 4 * x;\n}```\n"}
{"method_name": "DoubleQuadruple", "positive": "method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 4 * x;\n}\n````\n"}
{"method_name": "Swap", "positive": "method Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  // complete the method body\n  x := Y;\n  y := X;\n}```\n"}
{"method_name": "Swap", "positive": "method Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  // complete the method body\n  x := Y;\n  y := X;\n}\n````\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r := 3 * x;\n}\n````\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n{\n  // complete the method here\n  n := 0;\n  while n < a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i < n ==> e!=a[i]\n  {\n    if a[n] == e {\n      break;\n    }```\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n{\n  // complete the method here\n  n := 0;\n  while n < a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i < n ==> e!=a[i]\n  {\n    if a[n] == e {\n      break;\n    }```\n"}
{"method_name": "ComputeIsEven", "positive": "method ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n{\n  // complete the method body here\n  is_even := x % 2 == 0;\n}```\n"}
{"method_name": "ComputeIsEven", "positive": "method ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n{\n  // complete the method body here\n  is_even := x % 2 == 0;\n}\n````\n"}
{"method_name": "TestArrayElements", "positive": "method TestArrayElements(a:array<int>, j: nat, k: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n{\n  a[j] := 60;\n}```\n"}
{"method_name": "TestArrayElements", "positive": "method TestArrayElements(a:array<int>, j: nat, k: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n{\n  a[j] := 60;\n}\n````\n"}
{"method_name": "Abs", "positive": "method Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}```\n"}
{"method_name": "Abs", "positive": "method Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}```\n"}
{"method_name": "CanyonSearch", "positive": "method CanyonSearch(a: array<int>, b: array<int>) returns (d:nat)\n  requires a.Length !=0 && b.Length!=0\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  requires forall i,j :: 0<=i<j<b.Length ==> b[i]<=b[j]\n  ensures exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n  ensures forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n{\n  var m,n:=0,0;\n  d:=if a[0] < b[0] then (b[0]-a[0]) else (a[0]-b[0]);\n  while m<a.Length && n<b.Length\n    invariant 0<=m<=a.Length && 0<=n<=b.Length\n    decreases a.Length -m+b.Length-n\n    invariant exists i,j:: 0<=i<a.Length && 0<=j<b.Length && d==if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j])\n    invariant forall i,j:: 0<=i<a.Length && 0<=j<b.Length ==> d<=(if a[i] < b[j] then (b[j]-a[i]) else (a[i]-b[j]))|| (m<=i&&n<=j)\n  {\n    var t := if a[m] < b[n] then (b[n]-a[m]) else (a[m]-b[n]);\n    d:=if t<d then t else d;\n    if\n    case a[m]<=b[n] =>\n      m:=m+1;\n    case b[n]<=a[m] =>\n      n:=n+1;\n\n  }\n}```\n"}
{"method_name": "remove", "positive": "method remove_front(a:array<int>) returns (c:array<int>)\n  requires a.Length>0\n  ensures  a[1..] == c[..]\n{\n  c := new int[a.Length-1];\n  var i:= 1;\n  while (i < a.Length)\n    invariant 1 <= i <= a.Length\n    invariant forall ii::1<=ii<i ==> c[ii-1]==a[ii]\n  {\n    c[i-1] := a[i];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "LongestCommonPrefix", "positive": "method LongestCommonPrefix(str1: seq<char>, str2: seq<char>) returns (prefix: seq<char>)\n  ensures |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  ensures |prefix|==|str1| || |prefix|==|str2| || (str1[|prefix|]!=str2[|prefix|])\n{\n  prefix := [];\n  var minLength := if |str1| <|str2| then |str1| else |str2|;\n\n  for idx:= 0 to minLength\n    invariant |prefix|==idx <=  minLength<=|str1| && minLength<=|str2|\n    invariant |prefix| <= |str1| && prefix == str1[0..|prefix|]&& |prefix| <= |str2| && prefix == str2[0..|prefix|]\n  {\n    if str1[idx] != str2[idx] {\n      return;\n    }\n    prefix := prefix + [str1[idx]];\n  }\n}```\n"}
{"method_name": "SquareRoot", "positive": "method SquareRoot(N:nat) returns (r:nat)\n  ensures r*r <= N < (r+1)*(r+1)\n{\n  r:=0;\n  while (r+1)*(r+1)<=N\n    invariant r*r<=N\n  {\n    r:=r+1;\n  }\n}```\n"}
{"method_name": "reverse", "positive": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i       := 0;\n  var aLength := a.Length;\n\n  var b := new int[a.Length];\n\n  while i < aLength\n    invariant 0 <= i && i <= aLength\n    invariant forall k :: 0 <= k < i ==> b[k] == a[aLength - 1 - k]\n    invariant forall k :: 0 <= k < aLength ==> a[k] == old(a[k])\n  {\n    b[i] := a[aLength - 1 - i];\n    i := i + 1;\n  }\n\n  i := 0;\n  while i < aLength\n    invariant 0 <= i && i <= aLength\n    invariant forall k :: 0 <= k < aLength ==> b[k] == old(a[aLength - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[k] == b[k]\n  {\n      a[i] := b[i];\n      i := i + 1;\n  }\n}```\n"}
{"method_name": "insert", "positive": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length \n  requires 0 <= p <= nl.Length \n  requires 0 <= at <= l \n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i] \n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n\n  var i:int := l;\n  while(i>at)\n    invariant line[0..i] == initialLine[0..i]\n    invariant line[i+p..l+p] == initialLine[i..l]\n    invariant at<=i<=l\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n\n  assert line[0..at] == initialLine[0..at];\n  assert line[at+p..l+p] == initialLine[at..l];\n\n  i := 0;\n  while(i<p)\n    invariant 0<=i<=p\n    invariant line[0..at] == initialLine[0..at]\n    invariant line[at..at+i] == nl[0..i]\n    invariant line[at+p..l+p] == initialLine[at..l]\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n\n  assert line[0..at] == initialLine[0..at];\n  assert line[at..at+p] == nl[0..p];\n  assert line[at+p..l+p] == initialLine[at..l];\n}```\n"}
{"method_name": "UpdateElements", "positive": "method UpdateElements(a: array<int>)\n  requires a.Length >=9\n  modifies a\n  ensures old(a[4]) +3 == a[4]\n  ensures a[8] == old(a[8])\n  ensures a[7]==516\n{\n  a[4], a[8] := a[4] + 3, a[8] + 1;\n  a[7], a[8] := 516, a[8] - 1;\n}```\n"}
{"method_name": "rotate", "positive": "method rotate(a: array<int>, offset:int) returns (b: array<int> )\n  requires 0<=offset<=a.Length\n  ensures b.Length==a.Length\n  ensures forall i ::0<=i<a.Length ==>  b[(i+offset)%a.Length]==a[i]\n{\n  b:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j::0<=j<i ==> b[(j+offset)%a.Length]==a[j]\n  {\n    assert (i+offset)%a.Length == (if i+offset>=a.Length then i+offset-a.Length else i+offset);\n    var dest:= (i+offset)%a.Length;\n    b[dest]:=a[i];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "update", "positive": "method update_map<K(!new), V>(m1: map<K, V>, m2: map<K, V>) returns (r: map<K, V>)\n  ensures (forall k :: k in m2 ==> k in r)\n  ensures (forall k :: k in m1 ==> k in r)\n  ensures  (forall k :: k in m2 ==> r[k] == m2[k])\n  ensures  (forall k :: !(k in m2) && k in m1 ==> r[k] == m1[k])\n  ensures  (forall k :: !(k in m2) && !(k in m1) ==> !(k in r))\n{\n  r:= map k | k in (m1.Keys + m2.Keys) :: if k in m2 then m2[k] else m1[k];\n}```\n"}
{"method_name": "copy", "positive": "method copy( src: array<int>, sStart: nat, dest: array<int>, dStart: nat, len: nat) returns (r: array<int>)\n   requires src.Length >= sStart + len\n   requires dest.Length >= dStart + len\n   ensures r.Length == dest.Length\n   ensures r[..dStart] == dest[..dStart]\n   ensures r[dStart + len..] == dest[dStart + len..]\n   ensures forall k:int :: dStart<= k < len+dStart ==> r[k] == src[sStart + k-dStart]\n\n{\n    if len == 0 { return dest; }\n    var i: nat := 0;\n    r := new int[dest.Length];\n    while (i < r.Length)\n      invariant i <= r.Length\n      invariant r[..i] == dest[..i]\n    {\n        r[i] := dest[i];\n        i := i + 1;\n    }\n\n    i := 0;\n    while (i < len)\n      invariant i <= len\n      invariant r[..dStart] == dest[..dStart]\n      invariant r[(dStart + len)..] == dest[(dStart + len)..]\n      invariant r[dStart .. dStart + i] == src[sStart .. sStart + i]\n      {\n        r[dStart + i] := src[sStart + i];\n        i := i + 1;\n    }\n}```\n"}
{"method_name": "Min", "positive": "method Min(x: int, y:int) returns (z: int)\n  ensures x<=y ==> z==x\n  ensures x>y ==> z==y\n{\n  if x < y {\n    return x;\n  } else {\n    return y;\n  }\n}```\n"}
{"method_name": "has", "positive": "method has_close_elements(numbers: seq<real>, threshold: real) returns (res: bool)\n  ensures res ==> exists i: int, j: int :: 0 <= i < |numbers| && 0 <= j < |numbers| && i != j && (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) < threshold\n  ensures !res ==> (forall i: int, j: int :: 1 <= i < |numbers| && 0 <= j < i ==>  (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold)\n\n\n{\n\n  res := false;\n  var idx: int := 0;\n  while idx < |numbers| && !res\n    invariant 0 <= idx <= |numbers|\n    invariant !res\n    invariant forall i: int, j: int :: 0 <= i < idx && 0 <= j < i ==> (if numbers[i] - numbers[j] < 0.0 then numbers[j] - numbers[i] else numbers[i] - numbers[j]) >= threshold\n  {\n    var idx2: int := 0;\n    while idx2 < idx && !res\n      invariant 0 <= idx <= |numbers|\n      invariant 0 <= idx2 <= idx\n      invariant !res\n      invariant forall j: int :: 0 <= j < idx2 ==> (if numbers[idx] - numbers[j] < 0.0 then numbers[j] - numbers[idx] else numbers[idx] - numbers[j]) >= threshold\n    {\n\n      var distance :=  (if numbers[idx2] - numbers[idx] < 0.0 then numbers[idx] - numbers[idx2] else numbers[idx2] - numbers[idx]);\n      if distance < threshold  {\n        res := true;\n        return;\n      }\n\n      idx2 := idx2 + 1;\n    }\n    idx := idx + 1;\n  }\n}```\n"}
{"method_name": "arraySum", "positive": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j:: 0 <= j< i==> a[j] + b[j]==c[j]\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "ComputeAvg", "positive": "method ComputeAvg(a: int, b: int) returns (avg:int)\n  ensures avg == (a+b)/2\n{\n  avg:= (a + b) / 2;\n}```\n"}
{"method_name": "CalDiv", "positive": "method CalDiv() returns (x:int, y:int)\n  ensures x==191/7\n  ensures y==191%7\n{\n\n  x, y := 0, 191;\n  while 7 <= y\n    invariant 0 <= y && 7 * x + y == 191\n  {\n    x := x+1;\n    y:=191-7*x;\n  }\n}```\n"}
{"method_name": "swap", "positive": "method swap(arr: array<int>, i: int, j: int)\n  requires 0 <= i < arr.Length && 0 <= j < arr.Length\n  modifies arr\n  ensures arr[i] == old(arr[j]) && arr[j] == old(arr[i])\n  ensures forall k :: 0 <= k < arr.Length && k != i && k != j ==> arr[k] == old(arr[k])\n{\n  var tmp := arr[i];\n  arr[i] := arr[j];\n  arr[j] := tmp;\n}```\n"}
{"method_name": "Find", "positive": "method Find(a: array<int>, key: int) returns (index: int)\n  ensures -1<=index<a.Length\n  ensures index!=-1 ==> a[index]==key && (forall i :: 0 <= i < index ==> a[i] != key)\n  ensures index == -1 ==> (forall i::0 <= i < a.Length ==> a[i] != key)\n{\n  index := 0;\n  while index < a.Length\n    invariant 0<=index<=a.Length\n    invariant (forall i::0 <= i < index==>a[i] != key)\n  {\n    if a[index] == key { return; }\n    index := index + 1;\n  }\n  if index >= a.Length  {\n    index := -1;\n  }\n}```\n"}
{"method_name": "replace", "positive": "method replace(arr: array<int>, k: int)\n  modifies arr\n  ensures forall i :: 0 <= i < arr.Length ==> (((old(arr[i]) > k) ==> arr[i] == -1) && ((old(arr[i]) <= k) ==> arr[i] == old(arr[i])))\n{\n  var i := 0;\n  while i < arr.Length\n    decreases arr.Length - i\n    invariant 0 <= i <= arr.Length\n    invariant forall j :: 0 <= j < i ==>\n                            (((old(arr[j]) > k) ==> arr[j] == -1) &&\n                             ((old(arr[j]) <= k) ==> arr[j] == old(arr[j])))\n    invariant forall j :: i <= j < arr.Length ==> old(arr[j]) == arr[j]\n  {\n    if arr[i] > k {\n      arr[i] := -1;\n    }\n    i := i + 1;\n  }\n}```\n"}
{"method_name": "BubbleSort", "positive": "method BubbleSort(a: array<int>)\n  modifies a\n  ensures forall i,j::0<= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..])==multiset(old(a[..]))\n{\n  var i := a.Length - 1;\n  while (i > 0)\n    invariant i < 0 ==> a.Length == 0\n    invariant -1 <= i < a.Length\n    invariant forall ii,jj::i <= ii< jj <a.Length ==> a[ii] <= a[jj]\n    invariant forall k,k'::0<=k<=i<k'<a.Length==>a[k]<=a[k']\n    invariant multiset(a[..])==multiset(old(a[..]))\n  {\n    var j := 0;\n    while (j < i)\n      invariant 0 < i < a.Length && 0 <= j <= i\n      invariant forall ii,jj::i<= ii <= jj <a.Length ==> a[ii] <= a[jj]\n      invariant forall k, k'::0<=k<=i<k'<a.Length==>a[k]<=a[k']\n      invariant forall k :: 0 <= k <= j ==> a[k] <= a[j]\n      invariant multiset(a[..])==multiset(old(a[..]))\n    {\n      if (a[j] > a[j + 1])\n      {\n        a[j], a[j + 1] := a[j + 1], a[j];\n      }\n      j := j + 1;\n    }\n    i := i - 1;\n  }\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  if x==0 {\n    r:=0;\n  }\n  else{\n    var y:=2*x;\n    r:= x+y;\n  }\n}```\n"}
{"method_name": "LinearSearch3", "positive": "method LinearSearch3<T>(a: array<T>, P: T -> bool) returns (n: int)\n  requires exists i :: 0 <= i < a.Length && P(a[i])\n  ensures 0 <= n < a.Length && P(a[n])\n  ensures forall k :: 0 <= k < n ==> !P(a[k])\n{\n  n := 0;\n  while true\n    invariant 0 <= n < a.Length\n    invariant exists i :: n <= i < a.Length && P(a[i])\n    invariant  forall k :: 0 <= k < n ==> !P(a[k])\n    decreases a.Length - n\n  {\n    if P(a[n]) {\n      return;\n    }\n    n := n + 1;\n  }\n}```\n"}
{"method_name": "convert", "positive": "method convert_map_key(inputs: map<nat, bool>, f: nat->nat) returns(r:map<nat, bool>)\n  requires forall n1: nat, n2: nat :: n1 != n2 ==> f(n1) != f(n2)\n  ensures forall k :: k in inputs <==> f(k) in r\n  ensures forall k :: k in inputs ==> r[f(k)] == inputs[k]\n{\n  r:= map k | k in inputs :: f(k) := inputs[k];\n}```\n"}
{"method_name": "modify", "positive": "method modify_array_element(arr: array<array<nat>>, index1: nat, index2: nat, val: nat)\n  requires index1 < arr.Length\n  requires index2 < arr[index1].Length\n  requires forall i: nat, j:nat :: i < arr.Length && j < arr.Length && i != j ==> arr[i] != arr[j]\n  modifies arr[index1]\n  ensures forall some_index1: nat, some_index2: nat ::\n            some_index1 < arr.Length && some_index2 < arr[some_index1].Length ==>\n              arr[some_index1][some_index2] == if index1 == some_index1 && index2 == some_index2\n              then val else old(arr[some_index1][some_index2])\n{\n  arr[index1][index2] := val;\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  var y:= x*2;\n  r := y+x;\n}```\n"}
{"method_name": "only", "positive": "method only_once<T(==)>(a: array<T>, key: T) returns (b:bool)\n  ensures (multiset(a[..])[key] ==1 ) <==> b\n{\n  var i := 0;\n  b := false;\n  var keyCount := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant multiset(a[..i])[key] == keyCount\n    invariant b <==> (keyCount == 1)\n  {\n    if (a[i] == key)\n    {\n      keyCount := keyCount + 1;\n    }\n    if (keyCount == 1)\n    { b := true; }\n    else\n    { b := false; }\n    i := i + 1;\n  }\n\n  assert a[..a.Length] == a[..];\n}```\n"}
{"method_name": "M", "positive": "method M(x: int) returns (seven: int)\n  ensures seven==7\n{\n  seven := 7;\n}```\n"}
{"method_name": "Sum", "positive": "method Sum() returns (s:int, n:int)\n  ensures s == n * (n + 1) / 2\n  ensures n==33\n{\n  n, s := 0, 0;\n  while n != 33\n    invariant s == n * (n + 1) / 2\n  {\n    n := n + 1;\n    s := s + n;\n  }\n}```\n"}
{"method_name": "BinarySearch", "positive": "method BinarySearch(a: array<int>, key: int) returns (n: int)\n  requires forall i,j :: 0<=i<j<a.Length ==> a[i]<=a[j]\n  ensures 0<= n <=a.Length\n  ensures forall i :: 0<= i < n ==> a[i] < key\n  ensures n == a.Length ==> forall i :: 0 <= i < a.Length ==> a[i] < key;\n  ensures forall i :: n<= i < a.Length ==> a[i]>=key\n{\n  var lo, hi := 0, a.Length;\n  while lo<hi\n    invariant 0<= lo <= hi <= a.Length\n    invariant forall i :: 0<=i<lo ==> a[i] < key\n    invariant forall i :: hi<=i<a.Length ==> a[i] >= key\n  {\n    var mid := (lo + hi) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else {\n      hi := mid;\n    }\n  }\n  n:=lo;\n}```\n"}
{"method_name": "arrayProduct", "positive": "method arrayProduct(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] * b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n    invariant 0<=i<=a.Length\n    invariant forall j:: 0 <= j< i==> a[j] * b[j]==c[j]\n  {\n    c[i]:=a[i]*b[i];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "maxArray", "positive": "method maxArray(a: array<int>) returns (m: int)\n  requires a.Length >= 1\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var index := 1;\n  while (index < a.Length)\n    invariant 0 <= index <= a.Length\n    invariant forall k :: 0 <= k < index ==> m >= a[k];\n    invariant exists k :: 0 <= k < index && m == a[k];\n    decreases a.Length - index\n  {\n    m := if m>a[index] then  m else a[index];\n    index := index + 1;\n  }\n}```\n"}
{"method_name": "minArray", "positive": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall x :: 0 <= x < i ==> r <= a[x]\n    invariant exists x :: 0 <= x < i && r == a[x]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "concat", "positive": "method concat(a:array<int>, b:array<int>) returns (c:array<int>)\n  ensures c.Length==b.Length+a.Length\n  ensures forall k :: 0 <= k < a.Length ==> c[k] == a[k]\n  ensures forall k :: 0 <= k < b.Length ==> c[k+a.Length] == b[k]\n{\n  c := new int[a.Length+b.Length];\n  var i:= 0;\n  while (i < c.Length)\n    invariant 0 <= i <= c.Length\n    invariant if i<a.Length then c[..i]==a[..i] else c[..i]==a[..]+b[..(i-a.Length)]\n  {\n    c[i] := if i<a.Length then a[i] else b[i-a.Length];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "SetToSeq", "positive": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\n    invariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}```\n"}
{"method_name": "allDigits", "positive": "method allDigits(s: string) returns (result: bool)\n  ensures  result <==> (forall i :: 0 <= i < |s| ==> s[i] in \"0123456789\")\n{\n  result:=true ;\n  for i := 0 to |s|\n    invariant result <==> (forall ii :: 0 <= ii < i ==> s[ii] in \"0123456789\")\n  {\n    if ! (s[i] in \"0123456789\"){\n      return false;\n    }\n  }\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  if {\n    case x<18 =>\n      var a,b := 2*x, 4*x;\n      r:=(a+b)/2;\n    case 0<=x =>\n      var y:=2*x;\n      r:= x+y;\n  }\n}```\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  requires exists i::0<=i<a.Length && a[i]==e\n  ensures 0<=n<a.Length && a[n]==e\n  ensures forall k :: 0 <= k < n ==> a[k]!=e\n\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}```\n"}
{"method_name": "SelectionSort", "positive": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n:= 0;\n  while n != a.Length\n    invariant 0 <= n <= a.Length\n    invariant forall i, j :: 0 <= i < n <= j < a.Length ==> a[i] <= a[j]\n    invariant forall i,j :: 0 <= i < j < n ==> a[i] <= a[j]\n    invariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n+1;\n    while m != a.Length\n      invariant n <= mindex < m <= a.Length\n      invariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m+1;\n    }\n    a[n], a[mindex] := a[mindex], a[n];\n    n := n+1;\n  }\n}```\n"}
{"method_name": "below", "positive": "method below_zero(operations: seq<int>) returns (s:array<int>, result:bool)\n  ensures s.Length == |operations| + 1\n  ensures s[0]==0\n  ensures forall i :: 0 <= i < s.Length-1 ==> s[i+1]==s[i]+operations[i]\n  ensures result == true ==> (exists i :: 1 <= i <= |operations| && s[i] < 0)\n  ensures result == false ==> forall i :: 0 <= i < s.Length ==> s[i] >= 0\n{\n  result := false;\n  s := new int[|operations| + 1];\n  var i := 0;\n  s[i] := 0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant s[0]==0\n    invariant s.Length == |operations| + 1\n    invariant forall x :: 0 <= x < i-1 ==> s[x+1]==s[x]+operations[x]\n  {\n    if i>0{\n        s[i] := s[i - 1] + operations[i - 1];\n    }\n    i := i + 1;\n  }\n  i:=0;\n  while i < s.Length\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] >= 0\n  {\n    if s[i] < 0 {\n      result := true;\n      return;\n    }\n    i := i + 1;\n  }\n}```\n"}
{"method_name": "onlineMax", "positive": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\n    invariant 0<=i<=x\n    invariant forall j::0<=j<i==> a[j]<=best\n    invariant exists j::0<=j<i && a[j]==best\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n    invariant x<=i<=a.Length\n    invariant forall j::x<=j<i ==> a[j]<=m\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n\n}```\n"}
{"method_name": "iter", "positive": "method iter_copy<T(0)>(s: array<T>) returns (t: array<T>)\n  ensures s.Length==t.Length\n  ensures forall i::0<=i<s.Length ==> s[i]==t[i]\n{\n  t := new T[s.Length];\n  var i:= 0;\n  while (i < s.Length)\n    invariant 0 <= i <= s.Length\n    invariant forall x :: 0 <= x < i ==> s[x] == t[x]\n  {\n    t[i] := s[i];\n    i:=i+1;\n  }\n}```\n"}
{"method_name": "SwapBitvectors", "positive": "method SwapBitvectors(X: bv8, Y: bv8) returns(x: bv8, y: bv8)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n\n  x := x ^ y;\n  y := x ^ y;\n  x := x ^ y;\n\n}```\n"}
{"method_name": "MultipleReturns", "positive": "method MultipleReturns(x: int, y: int) returns (more: int, less: int)\n  ensures more == x+y\n  ensures less == x-y\n{\n  more := x + y;\n  less := x - y;\n}```\n"}
{"method_name": "DoubleQuadruple", "positive": "method DoubleQuadruple(x: int) returns (a: int, b: int)\n  ensures a == 2 * x && b == 4 * x\n{\n  a := 2 * x;\n  b := 2 * a;\n}```\n"}
{"method_name": "Swap", "positive": "method Swap(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n\n  var tmp := x;\n  x := y;\n  y := tmp;\n\n  assert x == Y && y == X;\n}```\n"}
{"method_name": "SlopeSearch", "positive": "method SlopeSearch(a: array2<int>, key: int) returns (m:int, n:int)\n  requires forall i,j,j'::0<=i<a.Length0 && 0<=j<j'<a.Length1 ==> a[i,j]<=a[i,j']\n  requires forall i,i',j::0<=i<i'<a.Length0 && 0<=j<a.Length1 ==> a[i,j]<=a[i',j]\n  requires exists i,j :: 0<=i<a.Length0 && 0<=j<a.Length1 && a[i,j]==key\n  ensures 0<=m<a.Length0 && 0<=n<a.Length1\n  ensures a[m,n]==key\n{\n  m,n:=0, a.Length1-1;\n  while a[m,n] !=key\n    invariant 0<=m<a.Length0 && 0<=n<a.Length1\n    invariant exists i,j :: m<=i<a.Length0 && 0<=j<=n && a[i,j]==key\n    decreases a.Length0-m+n\n  {\n    if a[m,n] < key {\n      m:=m+1;\n\n    }else{\n      n:=n-1;\n    }\n  }\n}```\n"}
{"method_name": "SwapSimultaneous", "positive": "method SwapSimultaneous(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n{\n  x, y := X, Y;\n  x, y := y, x;\n}```\n"}
{"method_name": "append", "positive": "method append(a:array<int>, b:int) returns (c:array<int>)\n  ensures  a[..] + [b] == c[..]\n{\n  c := new int[a.Length+1];\n  var i:= 0;\n  while (i < a.Length)\n    invariant 0 <= i <= a.Length\n    invariant forall ii::0<=ii<i ==> c[ii]==a[ii]\n  {\n    c[i] := a[i];\n    i:=i+1;\n  }\n  c[a.Length]:=b;\n}```\n"}
{"method_name": "Triple", "positive": "method Triple (x:int) returns (r:int)\n  ensures r==3*x\n{\n  r:= x*3;\n}```\n"}
{"method_name": "LinearSearch", "positive": "method LinearSearch(a: array<int>, e: int) returns (n:int)\n  ensures 0<=n<=a.Length\n  ensures n==a.Length || a[n]==e\n  ensures forall i::0<=i < n ==> e!=a[i]\n{\n  n :=0;\n  while n!=a.Length\n    invariant 0<=n<=a.Length\n    invariant forall i::0<=i<n ==> e!=a[i]\n  {\n    if e==a[n]{\n      return;\n    }\n    n:=n+1;\n  }\n}```\n"}
{"method_name": "IsPalindrome", "positive": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\n    invariant 0<=i<=j+1 && 0<=j < |x|\n    invariant i+j==|x|-1\n    invariant (forall k :: 0 <= k < i ==> x[k] == x[|x| - k - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}```\n"}
{"method_name": "Quotient", "positive": "method Quotient(x: nat, y:nat) returns (r:int, q:int)\n  requires y != 0\n  ensures q*y+r==x && y>r>=0 && q>=0\n{\n  r:=x;\n  q:=0;\n  while y<=r\n    invariant q*y+r==x && r>=0\n    decreases r\n  {\n    r:=r-y;\n    q:=q+1;\n\n  }\n}```\n"}
{"method_name": "SwapArithmetic", "positive": "method SwapArithmetic(X: int, Y: int) returns(x: int, y: int)\n  ensures x==Y\n  ensures y==X\n\n{\n  x, y := X, Y;\n\n  x := y - x;\n  y := y - x;\n  x := y + x;\n\n}```\n"}
{"method_name": "FindEvenNumbers", "positive": "method FindEvenNumbers (arr: array<int>) returns (evenNumbers: array<int>)\n  ensures forall x {:trigger (x%2) }:: x in arr[..] &&  (x%2==0)==> x in evenNumbers[..];\n  ensures forall x :: x !in arr[..] ==> x !in evenNumbers[..]\n  ensures forall k :: 0 <= k < evenNumbers.Length ==> evenNumbers[k] % 2 == 0\n  ensures forall k, l :: 0 <= k < l < evenNumbers.Length ==>\n                           exists n, m :: 0 <= n < m < arr.Length && evenNumbers[k] == arr[n] && evenNumbers[l] == arr[m]\n\n{\n  var evenList: seq<int> := [];\n  ghost var indices: seq<int> := [];\n\n  for i := 0 to arr.Length\n    invariant 0 <= i <= arr.Length\n    invariant 0 <= |evenList| <= i\n    invariant forall x  {:trigger (x%2) }:: (x in arr[..i] && (x%2==0) )==> x in evenList[..]\n    invariant forall k :: 0 <= k < |evenList| ==> evenList[k] % 2 == 0\n    invariant forall x :: x !in arr[..i] ==> x !in evenList\n    invariant |evenList| == |indices|\n    invariant forall k :: 0 <= k < |indices| ==> indices[k] < i\n    invariant forall k, l :: 0 <= k < l < |indices| ==> indices[k] < indices[l]\n    invariant forall k :: 0 <= k < |evenList| ==> 0 <= indices[k] < i <= arr.Length && arr[indices[k]] == evenList[k]\n  {\n    if arr[i]%2==0\n    {\n      evenList := evenList + [arr[i]];\n      indices := indices + [i];\n    }\n  }\n\n  evenNumbers := new int[|evenList|](i requires 0 <= i < |evenList| => evenList[i]);\n  assert evenList == evenNumbers[..];\n}```\n"}
{"method_name": "twoSum", "positive": "method twoSum(nums: array<int>, target: int) returns (i: int, j: int)\n  requires nums.Length > 1\n  requires exists i,j::0 <= i < j < nums.Length &&  nums[i] + nums[j] == target\n  ensures 0 <= i < j < nums.Length && nums[i] + nums[j] == target\n  ensures forall ii,jj:: (0 <= ii < i && ii < jj < nums.Length) || (ii == i && ii < jj < j) ==> nums[ii] + nums[jj] != target\n\n{\n  var n := nums.Length;\n  i := 0;\n  j := 1;\n  while i < n - 1\n    invariant 0 <= i < j <= n\n    invariant forall ii, jj :: 0 <= ii < i && ii < jj < n ==> nums[ii] + nums[jj] != target\n  {\n    j := i + 1;\n    while j < n\n      invariant 0 <= i < j <= n\n      invariant forall jj :: i < jj < j ==> nums[i] + nums[jj] != target\n    {\n      if nums[i] + nums[j] == target {\n        return;\n      }\n      j := j + 1;\n    }\n\n    i := i + 1;\n  }\n}```\n"}
{"method_name": "ComputeIsEven", "positive": "method ComputeIsEven(x:int) returns (is_even:bool)\n  ensures (x % 2 == 0)==is_even\n{\n  is_even:=false;\n  if x%2==0{\n    is_even:=true;\n  }\n}```\n"}
{"method_name": "CountLessThan", "positive": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n    decreases shrink\n    invariant shrink + grow == numbers\n    invariant grow !! shrink\n    invariant count == |set i | i in grow && i < threshold|\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n    assert (set i | i in grow' && i < threshold) ==\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}```\n"}
{"method_name": "TestArrayElements", "positive": "method TestArrayElements(a:array<int>, j: nat, k: nat)\n  requires 0<=j < a.Length\n  modifies a\n  ensures a[j] == 60\n{\n  a[j] := 60;\n}```\n"}
{"method_name": "Abs", "positive": "method Abs(x: int) returns (y: int)\n  ensures x>=0 ==> x==y\n  ensures x<0 ==> x+y==0\n{\n  if x < 0 {\n    return -x;\n  } else {\n    return x;\n  }\n}```\n"}
{"method_name": "ToArray", "positive": "method ToArray<T>(xs: seq<T>) returns (a: array<T>)\n  ensures fresh(a)\n  ensures a.Length == |xs|\n  ensures forall i :: 0 <= i < |xs| ==> a[i] == xs[i]\n{\n  a := new T[|xs|](i requires 0 <= i < |xs| => xs[i]);\n}```\n"}
{"method_name": "Compare", "positive": "method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n  ensures a==b ==> eq==true\n  ensures a!=b ==> eq==false\n{\n  if a == b { eq := true; } else { eq := false; }\n}```\n"}
